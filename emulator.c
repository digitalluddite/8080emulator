/*
	8080 Emulator because why not?

	information about the 8080:

	the computer is represented as consisting of:

	* 	Seven working registers in which all data operations occur, and
		which provide one means for addressing memory
	* 	memory, which may hold program instructions or data and which must
		be addressed location by location in order to access stored information
	* 	The program counter, whose contents indicate the next program 
		instruction to be executed.
	*	The stack pointer, a register which enables various portions of memory
		to be used as stacks.  These in turn facilitate execution of subroutines
		and handling of interrupts as described later.
	*	Input/output, whihc is the interface between a program and the 
		outside world.

	Registers:
		8-bit accumulator and 6 additional "scratchpad" registers
		Registers are numbered and refenced with integers 
			0, 1, 2, 3, 4, 5, 6, 7 or B, C, D, E, H, L, A (accumulator)
															
		Some instructions reference registers in pairs with B, D, H, PSW

			B		B and C (0 and 1)
			D		D and E (2 and 3)
			H		H and L (4 and 5)
			PSW		See below

		PSW (program status word) refers to register A(7) and a 
		special, machine flags byte

	Memory addresses -- 16 bit
	Program Counter -- 16 bit register
		-- just before an instruction is executed, the program counter is 
			advanced to the address of the next sequential instruction.
	Stack pointer -- 16 bit register

	Memory addressing:
		Direct (little endian)
		Register pair
			For most 8080 instructions, the H and L registers must be used. 
			The H register contains the most significant 8bits and the L 
			register the least-significant

		STAX and LDAX instructions use (B and C) or (D and E) register pairs


	Stack Push
		16-bits of data are transferred to stack
			1.  The most significant byte is stored at the memory address _one 
				less_ than the contents of the stack pointer
			2.  The least signficant byte is stored at the memory address _two 
				less_ than the contents of the stack pointer
			3.  the stackpointer is automatically decremented by two

	Stack Pop
		1.  The second register of the pair, or the least significant byte of 
			the program counter, are loaded from the memory address helf in 
			the stack pointer
		2.  The first register of the pair, or the most significant byte of the 
			program counter are loaded from the memory address one greater than 
			the address held in the stack pointer.
		3.	The stack pointer is automatically incremented by two

	The programmer loads the stack poitner with any desired value by using LXI 
	instruction.  The programmer must initialize the stack pointer before 
	performing a stack operation

	Call/Return Similar to modern Intel:
		1.  Address of instruction after CALL is pushed to stack
		2.  RETURN instruction pops address off stack, sets to PC

	Condition bits
		*	Five condition bits are provided.  All but one (the auxillary carry 
			bit) may be tested by program instructions which affect subesequent 
			program execution.

		Carry Bit
			Set if operation results in a carry out of the high-order bit; 
			reset otherwise

		Auxillary Carry Bit
			Indicates carry out of bit 3
			Enables DAA instruction

		Sign Bit
			At conclusion of certain instructions, the sign bit will be set to 
			the condition of the most significant bit of the answer (bit 7)

		Zero Bit
			Set if the result generated by certain instructions is zero
			Carry Bit can also be set by same operation (i.e., operation results
			in a carry but resulting 8-bits are zero)

		Parity Bit
			Set if the total number of 1 bits is even, reset if odd
*/
#include <stdio.h>
#include <unistd.h>
#include <strings.h>
#include <stdint.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>

#include "cpu.h"
#include "machine.h"
#include "debug.h"

static int disassemble_rom(const char* rom) 
{
	struct stat _buf;
	if (stat(rom, &_buf) < 0) {
		perror(rom);
		return -1;
	}

	unsigned char *buf = (unsigned char*)malloc(_buf.st_size);
	bzero(buf, _buf.st_size);
	
	FILE *fp = fopen(rom, "rb");
	if (!fp) {
		perror(rom);
		return -1;
	}	
	fread(buf, 1, _buf.st_size, fp);
	fclose(fp);


	
	uint16_t offset = 0;
	while (offset < _buf.st_size) 
	{
		int i;
		OPCODE_INFO inst = get_opcode_info(buf[offset]);
		char c = (inst.op_type == immediate) ?  '#' : '$';
		printf("%04X  ", offset);
		
		for (i = 0 ; i < inst.length ; ++i) {
			printf("%02X ", buf[offset+i]);
		}
		for (; i < 3 ; ++i) {
			printf("   ");
		}
		printf("  %s ", inst.mnemonic);
		switch(inst.length) {
			case 2:
				printf("%c%02X", c, buf[offset+1]);
				break;
			case 3:
				printf("%c%02X%02X", c, buf[offset+2], buf[offset+1]);
				break;
		}
		printf("\n");
		offset += inst.length;
	}
	free(buf);
	return 0;
}



/*
	fetches the next instruction (cpu->pc) and advanced
	the program counter
*/
INSTRUCTION get_next_instruction(CPU *cpu) {
	INSTRUCTION inst = {0};
	inst.opcode = cpu->memory[cpu->pc];
	cpu->pc++;
	switch (get_instruction_length(cpu)) {
		case 3:
			inst.operand2 = cpu->memory[cpu->pc+2];
			cpu->pc++;
		case 2:
			inst.operand1 = cpu->memory[cpu->pc+1];
			cpu->pc++;
	}
	return inst;
}



int load_rom(CPU* cpu, const char* rom) {
	struct stat _buf;
	if (stat(rom, &_buf) < 0) {
		perror(rom);
		return -1;
	}

	FILE *fp = fopen(rom, "rb");
	if (!fp) {
		perror(rom);
		return -1;
	}
	fread(cpu->memory, _buf.st_size, 1, fp);
	fclose(fp);
	return 0;
}


/*
	runs a program  loaded into the CPU.

	@param cpu -- initialized and loaded cpu
	@param step -- if 1, stops after each instruction
*/
int run(CPU *cpu, int step) {
	int halt = 0;
	while (!halt) {
		if (step) {
			debug_console(cpu);	
		}

		// get function that implements the next instruction
		cpufunc func = get_cpu_function(cpu);
		// get the actual instruction bytes (advances PC)
		INSTRUCTION inst = get_next_instruction(cpu);	
		// execution function
		func(cpu, &inst);
	}
}



__attribute__((noreturn))
void usage (const char* prog) {
	printf("Usage: %s [-d] <rom>\n"
		   "   -d       disassemble ROM image\n",
			prog);
	exit(0);
}


#ifndef _UNITTESTS_
int main(int argc, char** argv) {
	int opt = -1;
	int disassemble = 0;
	const char* rom = NULL;

	while ((opt = getopt(argc, argv, "dt")) != -1) 
	{
		switch (opt) {
				case 'd':
					disassemble = 1;
					break;
				case 't':
					{
						return 0;
					}
				default:
					usage(*argv);
		}
	}

	if (optind == argc) {
		printf("Missing ROM image\n");
		usage(*argv);
	}	

	rom = argv[optind];


	if (!disassemble) {
		fprintf(stderr, "Disassembly is the only thing we do right now...\n");
		return -1;
	} else {
		disassemble_rom(rom);
	}

	return 0;
}

#endif


